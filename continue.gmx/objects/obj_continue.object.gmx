<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>10000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///initialiiiiiiiiiiiiiiiiiiiize

xrot = 0;   //Roll
yrot = 0;   //Pitch
zrot = 0;   //Yaw

sep = 200;
textScale = 250;

hueShift = 0;

/*COLONEL'S NOTE: Here Z is the up vector instead of Y.
I know it's not traditional. That's just what I'm used to.

If you don't like it.




die*/

xx = 0;
yy = -100;
zz = 0;

num = spr_numbers;
numIndex = 20;

numW = sprite_get_width(num);
numH = sprite_get_height(num);

xspd = 0;
yspd = 0;
zspd = 0;

cMap = getSpriteColors(num, numIndex);

bgX = 0;
bgSpeed = 0;

/*COLONEL'S NOTE: Initially all the circles were drawn in the obj_continue object,
but I didn't want to go through the pain of depth sorting them.
Instead, I just created them using separate objects, setting the depth equal to y
*/

//Initialize circles
for(var i=0; i&lt;numW; i++){
    for(var j=0; j&lt;numH; j++){
        circle[i, j] = instance_create(0, 0, obj_circle);
    }
}

//COLONEL'S NOTE: This starts moving the CONTINUE? background
alarm[0] = 25;

n = 0;

bg[0] = bck_comeOn;
bg[1] = bck_hurry;
bg[2] = bck_theMatter;
bg[3] = bck_back;

prevBG = 0;
alphaSpeed = 0;
flashTime = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Alram

audio_play_sound(snd_tick, 0, 0);

//COLONEL'S NOTE: This changes the image index and the current color map
cMap = getSpriteColors(num, --numIndex);

/*COLONEL'S NOTE: If number index is 0 then the alarm is set to 30 frames instead of 60.
The only reason this happens is because I thought it'd be funnier if the change from the
fancy continue screen to the MS Paint-ass game over screen was more abrupt.*/
alarm[1] = room_speed*1/((numIndex == 0)+1);

//Game ov, man
if(numIndex &lt; 0) room_goto(rm_gmvmn);

//Change BG
if((numIndex mod 2) == 0) alphaSpeed = -0.05;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///BG Speed

bgSpeed = -3;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw GUI

//Font
draw_set_font(fnt_continue);

//Align text
textAlign(fa_center, fa_middle);

//Text scale
textScale += (1 - textScale)/3;

//Rotate
if(sep == 5) n = (n+1) mod 60;

//Number scale
var numScale = 1;
var s = 20;

/*COLONEL'S NOTE: All these maths are for flipping the text around
s is the period for half of the cosine function
It starts flipping at 60 frames minus s divided by 2
It stops flipping s frames afterwards*/
if(n &gt;= 60-s/2){
    numScale = abs(cos((n-60-s/2)*pi/s));
}
else if(n &lt;= s/2){
    numScale = abs(cos((n+s/2)*pi/s));
}

/*COLONEL'S NOTE: The commented out portion would've just made the CONTINUE text and countdown bob up and down.
Even I thought that was a little excessive.*/
var yy = 24;//+floor(sin(current_time/300)*4);

//COLONEL'S NOTE: This just makes the text flash
//COLONEL'S NOTE 2: Flash Flash Flash is a song composed by Yuzo Koshiro for the X68000 port of Bosconian.
//Flash flash flash
if(numIndex &lt;= 7 &amp;&amp; numIndex &gt; 5)
    flashTime++;
else if(numIndex &lt;= 5 &amp;&amp; numIndex &gt; 2)
    flashTime += 2;
else if(numIndex &lt;= 2)
    flashTime += 4;

if(flashTime mod 20 &gt; 10) exit;

//Shadow shadow
draw_set_colour(c_red);
//Continue text
draw_text_transformed(view_wview/2+1, yy+1.5, "CONTINUE", textScale, 1, 0);
//Numbersssss
draw_text_transformed(view_wview/2+1-72, yy+1.5, string(numIndex), numScale, 1, 0);
draw_text_transformed(view_wview/2+1+72, yy+1.5, string(numIndex), numScale, 1, 0);

//Actual text
draw_set_colour(c_white);
//Continue text
draw_text_transformed(view_wview/2, yy, "CONTINUE", textScale, 1, 0);
//Numbersssss
draw_text_transformed(view_wview/2-72, yy, string(numIndex), numScale, 1, 0);
draw_text_transformed(view_wview/2+72, yy, string(numIndex), numScale, 1, 0);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw some stuff mang

//COLONEL'S NOTE: Hue
col1 = make_colour_hsv(hueShift, 255, 128);
col2 = make_colour_hsv(hueShift, 255, 192);

//COLONEL'S NOTE: Debug camera controls that I never commented out
xx += (keyboard_check(ord('D'))-keyboard_check(ord('A')))*2;
yy -= (keyboard_check(ord('S'))-keyboard_check(ord('W')))*2;

///ZOOOOOOM
if(sep &gt; 5.005)
    /*COLONEL'S NOTE: Smoothly makes the ball separation distance shrink from the initial
    value to 5*/
    sep += (5 - sep)/5;
else if(sep != 5){
    /*COLONEL'S NOTE: Once the zooming has stopped, the SPEEN can begin
    also the timer starts*/
    sep = 5;
    xspd = 1;
    yspd = 0;
    zspd = 1;
    audio_play_sound(snd_tick, 0, 0);
    alarm[1] = room_speed*1;
}

//COLONEL'S NOTE: SPEEEEEN
xrot += xspd;
yrot += yspd;
zrot += zspd;

for(var i=0; i&lt;numW; i++){
    for(var j=0; j&lt;numH; j++){
        /*COLONEL'S NOTE: CX, CY, and CZ are the circle positions, TX, TY, and TZ
        are temporary values used for rotations*/
        var cx, cy, cz, tx, ty, tz;
        //COLONEL'S NOTE: Most of my comments are stupid dumb garbage like you see below, btw.
        //Skip to the loops my daarling
        if(cMap[i, j] != c_white){
            circle[i, j].visible = false;
            continue;
        }
        circle[i, j].visible = true;
        //Points
        cx = (i-numW/2)*sep;
        cy = 0;
        cz = (j-numH/2)*sep;
        
        /*COLONEL'S NOTE: rotating a point about the origin works like so:
        x' = x*cos(angle)âˆ’y*sin(angle)
        y' = y*cos(angle)+x*sin(angle)
        (lengthdir_x(length, direction) is the same as length*cos(direction),
        same goes for lengthdir_y and sin)
        So for each rotation, I take the circle's position, rotate them and store them
        into the temporary positions, and then reassign them to circle's position.
        */
        
        //Rotate them points using temp values
        //Yaw
        tx = lengthdir_x(cx, zrot)+lengthdir_y(cy, zrot);
        ty = lengthdir_x(cy, zrot)-lengthdir_y(cx, zrot);
        //Reassign
        cx = tx;
        cy = ty;
        //Pitch
        tx = lengthdir_x(cx, yrot)+lengthdir_y(cz, yrot);
        tz = lengthdir_x(cz, yrot)-lengthdir_y(cx, yrot);
        //Reassign
        cx = tx;
        cz = tz;
        //Roll
        tz = lengthdir_x(cz, xrot)+lengthdir_y(cy, xrot);
        ty = lengthdir_x(cy, xrot)-lengthdir_y(cz, xrot);
        //Reassign
        cz = tz;
        cy = ty;
        //Circle
        circle[i, j].xx = cx-xx;
        circle[i, j].yy = cy-yy;
        circle[i, j].zz = cz;
    }
}

//COLONEL'S NOTE: The mod wraps the value back to 0 if it's above 255, but you probably knew that already
hueShift = (hueShift + 2) mod 256;

//Background X
bgX += bgSpeed;

//CONTINUE????
draw_background_tiled(bck_continue, bgX+320, 0);
draw_background(bck_black, bgX, 0);

/*COLONEL'S NOTE: The background text is actually TWO backgrounds because I couldn't be
arsed to tile them properly myself*/

//BG alpha
background_alpha[0] += alphaSpeed;
background_alpha[1] += alphaSpeed;

//BG Alpha Lower Limit
if(background_alpha[0] &lt;= 0){
    alphaSpeed = -alphaSpeed;
    //Pick at random
    var rand = irandom(3);
    if(rand == prevBG) rand = (rand+1) mod 4;
    //Assign BG
    background_index[0] = bg[rand];
    background_index[1] = bg[rand];
    //Set BG offset
    background_x[1] = background_x[0]+background_get_width(bg[rand])/3;
    prevBG = rand;
}
//BG Alpha Upper limit
if(background_alpha[0] &gt; 1){
    background_alpha[0] = 1;
    background_alpha[1] = 1;
    alphaSpeed = 0;
}

//Debug
/*
draw_text(0, 0, "Roll: " + string(xrot) + ", Pitch: " + string(yrot) + ", Yaw: " + string(zrot) + "
FPS: " + string(fps_real));*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="82">
      <action>
        <libid>1</libid>
        <id>331</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_restart_game</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
